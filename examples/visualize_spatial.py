
"""
Visualizes the disjoint 2D regions generated by eule using Matplotlib.
This script demonstrates the "Spatial Analysis" capability of eule.
"""
try:
    import matplotlib.pyplot as plt
    import matplotlib.patches as patches
    import matplotlib.colors as mcolors
    import matplotlib.lines as mlines
    from interval_sets import Interval, Box, BoxSet
    from eule import euler
except ImportError as e:
    print(f"Missing dependency: {e}")
    print("pip install matplotlib interval-sets eule")
    exit(1)

def is_close(a, b, tol=1e-5):
    return abs(a - b) < tol

def is_on_boundary(val, intervals):
    """Check if value 'val' is one of the endpoints of any interval in the list."""
    for i in intervals:
        if is_close(val, i.start) or is_close(val, i.end):
            return True
    return False

def is_segment_on_boundary(val, range_start, range_end, intervals, axis_idx):
    """
    Check if the segment defined by 'val' (fixed coordinate) and [range_start, range_end]
    lies on the boundary of any box in 'intervals'.
    
    intervals: List of Boxes (from the original set)
    axis_idx: 0 for vertical segment (fixed x), 1 for horizontal (fixed y)
    """
    for box in intervals:
        # box has [x_interval, y_interval]
        fixed_int = box.intervals[axis_idx]      # The dimension matching 'val'
        spanning_int = box.intervals[1-axis_idx] # The other dimension
        
        # 1. Does 'val' align with a boundary in the fixed dimension?
        if is_close(val, fixed_int.start) or is_close(val, fixed_int.end):
            # 2. Does the segment [range_start, range_end] fall within the spanning interval?
            # It must be covered by the box's spanning edge.
            # We assume precision issues, so allow slight overlap/containment
            if (range_start >= spanning_int.start - 1e-5) and (range_end <= spanning_int.end + 1e-5):
                return True
    return False

def plot_smart_box(ax, box, color, parent_boxes_map, region_keys, alpha=0.5):
    """
    Plots a box with dashed lines for internal cuts and solid lines for original boundaries.
    
    parent_boxes_map: Dict[str, BoxSet] - Original sets
    region_keys: List[str] - Keys of sets this region belongs to
    """
    x_int = box.intervals[0]
    y_int = box.intervals[1]
    
    # Fill first (no edge)
    rect = patches.Rectangle(
        (x_int.start, y_int.start), 
        x_int.length(), 
        y_int.length(), 
        linewidth=0, 
        facecolor=color, 
        alpha=alpha
    )
    ax.add_patch(rect)
    
    # Collect all relevant original boxes from the sets this region belongs to
    relevant_original_boxes = []
    for k in region_keys:
        if k in parent_boxes_map:
            relevant_original_boxes.extend(parent_boxes_map[k].boxes)
            
    # Helper to Draw Edge
    def draw_edge(x1, y1, x2, y2, is_vertical):
        # Determine fixed val and range
        if is_vertical:
            val = x1
            r_start, r_end = sorted((y1, y2))
            axis = 0 # Fixed X
        else:
            val = y1
            r_start, r_end = sorted((x1, x2))
            axis = 1 # Fixed Y
            
        is_solid = is_segment_on_boundary(val, r_start, r_end, relevant_original_boxes, axis)
        
        style = '-' if is_solid else '--'
        width = 1.5 if is_solid else 0.8
        alpha_line = 1.0 if is_solid else 0.6
        
        ax.plot([x1, x2], [y1, y2], color='black', linestyle=style, linewidth=width, alpha=alpha_line)

    # Bottom (y=y_start)
    draw_edge(x_int.start, y_int.start, x_int.end, y_int.start, False)
    # Top (y=y_end)
    draw_edge(x_int.start, y_int.end, x_int.end, y_int.end, False)
    # Left (x=x_start)
    draw_edge(x_int.start, y_int.start, x_int.start, y_int.end, True)
    # Right (x=x_end)
    draw_edge(x_int.end, y_int.start, x_int.end, y_int.end, True)

def plot_box_simple(ax, box, color, alpha=0.5, label=None):
    x_int = box.intervals[0]
    y_int = box.intervals[1]
    rect = patches.Rectangle(
        (x_int.start, y_int.start), x_int.length(), y_int.length(), 
        linewidth=1, edgecolor='black', facecolor=color, alpha=alpha, label=label
    )
    ax.add_patch(rect)

def main():
    print("Generating Spatial Euler Diagram Visualization (Smart Borders)...")

    # 1. Define Zones
    zone_a = BoxSet([Box([Interval(0, 10), Interval(0, 10)])])  # [0,10]x[0,10]
    zone_b = BoxSet([Box([Interval(5, 15), Interval(5, 15)])])  # [5,15]x[5,15]
    zone_c = BoxSet([Box([Interval(8, 12), Interval(0, 20)])])  # Vertical Strip
    
    spatial_zones = {
        'Zone A': zone_a,
        'Zone B': zone_b,
        'Zone C': zone_c
    }

    diagram = euler(spatial_zones)

    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 7))
    
    # Plot 1: Originals
    ax1.set_title("Input Overlapping Zones")
    colors = ['r', 'g', 'b']
    for (name, zone), color in zip(spatial_zones.items(), colors):
        for box in zone.boxes:
            plot_box_simple(ax1, box, color, alpha=0.3, label=name)
            
    handles, labels = ax1.get_legend_handles_labels()
    by_label = dict(zip(labels, handles))
    ax1.legend(by_label.values(), by_label.keys())
    ax1.set_xlim(-2, 18)
    ax1.set_ylim(-2, 22)
    ax1.grid(True, linestyle='--', alpha=0.3)

    # Plot 2: Disjoint with Smart Borders
    ax2.set_title("Computed Disjoint Euler Regions\n(Dashed = Internal Cut, Solid = Original Boundary)")
    
    region_colors = list(mcolors.TABLEAU_COLORS.values())
    color_idx = 0
    legend_patches = []
    
    for region_keys, box_set in sorted(diagram.items(), key=lambda x: str(x[0])):
        if not box_set: continue
        
        color = region_colors[color_idx % len(region_colors)]
        color_idx += 1
        
        short_keys = [k.replace("Zone ", "") for k in region_keys]
        label = " & ".join(sorted(short_keys))
        
        # Plot boxes
        for box in box_set:
            plot_smart_box(ax2, box, color, spatial_zones, region_keys, alpha=0.7)
            
        legend_patches.append(patches.Patch(color=color, label=label, alpha=0.7))

    ax2.legend(handles=legend_patches, loc='upper right', bbox_to_anchor=(1.3, 1))
    ax2.set_xlim(-2, 18)
    ax2.set_ylim(-2, 22)
    ax2.grid(True, linestyle='--', alpha=0.3)

    plt.tight_layout()
    plt.savefig("euler_spatial_viz.png")
    print("Saved visualization to euler_spatial_viz.png")

if __name__ == "__main__":
    main()
